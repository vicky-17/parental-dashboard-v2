// ==========================================
// --- IMPORTS & DEPENDENCIES ---
// ==========================================
const express = require('express');         // Main web framework for building the API
const mongoose = require('mongoose');       // Object Data Modeling (ODM) library for MongoDB
const cors = require('cors');               // Middleware to allow cross-origin requests (frontend calling backend)
const jwt = require('jsonwebtoken');        // Used to securely transmit information between parties as a JSON object
require('dotenv').config();                 // Loads environment variables from a .env file into process.env
// const bcrypt = require('bcryptjs');      // (Commented out) Usually used to hash passwords before saving them
const path = require('path');               // Core Node module for handling file and directory paths
const http = require('http');               // Core Node module to create the HTTP server
const { Server } = require('socket.io');    // Library for real-time, bidirectional WebSocket communication
const cron = require('node-cron');          // Task scheduler for running jobs at specific times (like daily resets)
const webpush = require('web-push');        // Library to send push notifications to the browser





const admin = require("firebase-admin");

// Initialize Firebase Admin Securely
let serviceAccount;

if (process.env.FIREBASE_CREDENTIALS) {
    // 1. If running on Heroku, read the key from the Environment Variable
    serviceAccount = JSON.parse(process.env.FIREBASE_CREDENTIALS);
} else {
    // 2. If running locally on your computer, read from the physical file
    serviceAccount = require("./firebase-admin-key.json");
}

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount)
});




// ==========================================
// --- SERVER & SOCKET INITIALIZATION ---
// ==========================================
const app = express();
const server = http.createServer(app);

// Initialize Socket.io and allow Cross-Origin requests so the frontend dashboard can connect
const io = new Server(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});





// ==========================================
// --- CONFIGURATION & STATE ---
// ==========================================
const PORT = process.env.PORT || 3000;
const JWT_SECRET = 'your_super_secret_key_123'; // Secret used to sign/verify JWT tokens (keep this safe in production!)
const DAILY_RESET_TZ = process.env.DAILY_RESET_TZ || process.env.TZ || 'UTC'; // Timezone for cron jobs

// üîê In-Memory Pending Pairings Store
// Why: Temporarily holds 6-digit codes generated by the dashboard until the Android app claims them.
// Structure: { 'code': { userId, socketId, timestamp, timeoutId } }
const pendingPairings = {}; 




// ==========================================
// --- MIDDLEWARE ---
// ==========================================
app.use(cors());                           // Allows API requests from different domains/ports
app.use(express.json());                   // Parses incoming JSON payloads in the request body


// Point to the root directory and public directory
// [CORRECTION 1] - Fixed Pathing so Heroku can find index.html and shield-icon.png
const rootPath = path.join(__dirname, '../'); 
app.use(express.static(rootPath)); // Serves files from the root directory
app.use(express.static(path.join(rootPath, 'public'))); // Serves files from the public directory

// ADD THESE TWO LINES: Tells Heroku exactly where app.js and style.css live
app.use(express.static(__dirname)); // Serves app.js (which is inside the 'api' folder)
app.use(express.static(path.join(rootPath, 'src'))); // Serves style.css (which is inside the 'src' folder)




// ==========================================
// --- DATABASE CONNECTION ---
// ==========================================
const dbURI = process.env.MONGODB_URI;

mongoose.connect(dbURI, {
    useNewUrlParser: true,
    useUnifiedTopology: true
}).then(() => console.log('üì¶ [DB] ‚úÖ Successfully connected to MongoDB'))
  .catch(err => console.error('üì¶ [DB] ‚ùå MongoDB connection error:', err));








// ==========================================
// --- DATABASE SCHEMAS & MODELS ---
// ==========================================
// Why: Schemas define the structure of the data saved in MongoDB.

// 1. Parent Account Data
const UserSchema = new mongoose.Schema({
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true } // Note: In production, always hash passwords!
});

// 2. Linked Child Devices
const DeviceSchema = new mongoose.Schema({
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }, // Links device to parent
    deviceId: { type: String }, // Unique hardware ID from Android
    name: { type: String },
    pairingCode: { type: String },
    isPaired: { type: Boolean, default: false }
});

// 3. GPS Location History
const LocationSchema = new mongoose.Schema({
    deviceId: String,
    latitude: Number,
    longitude: Number,
    batteryLevel: Number, 
    timestamp: { type: Date, default: Date.now }
});

// 4. Installed Apps & Usage Rules
const AppRuleSchema = new mongoose.Schema({
    deviceId: String,
    packageName: String, // e.g., "com.google.android.youtube"
    appName: String,
    category: { type: String, default: 'General' }, 
    isGlobalLocked: { type: Boolean, default: false }, 
    schedules: [{ 
        id: String,
        day: { type: String, default: 'Everyday' },
        start: String, // "HH:mm" (24-hour format)
        end: String    // "HH:mm" (24-hour format)
    }],
    timeLimit: { type: Number, default: 0 }, // Max minutes allowed per day
    usedToday: { type: Number, default: 0 }  // Minutes used today
});

// 5. Browser History & Web Filtering Rules
const WebFilterSchema = new mongoose.Schema({
    deviceId: { type: String, required: true, unique: true },
    blockedCategories: { type: [String], default: [] },
    blockedUrls: { type: [String], default: [] },
    history: [{
        url: String,
        title: String,
        timestamp: { type: Date, default: Date.now },
        riskScore: { type: Number, default: 0 } // Used by AI to rate danger level
    }]
});

// 6. Geofencing Zones
const ZoneSchema = new mongoose.Schema({
    deviceId: String,
    name: String,
    type: { type: String, enum: ['safe', 'danger'], default: 'safe' },
    alertMessage: String,
    points: [{ lat: Number, lng: Number }], // Defines the shape of the area on the map
    createdAt: { type: Date, default: Date.now }
});

// 7. General System Alerts/Notifications
const AlertSchema = new mongoose.Schema({
    deviceId: String,
    message: String,
    type: { type: String, enum: ['info', 'warning', 'critical'], default: 'info' },
    timestamp: { type: Date, default: Date.now },
    isRead: { type: Boolean, default: false }
});

// 8. Global Device Restrictions
const SettingsSchema = new mongoose.Schema({
    deviceId: { type: String, required: true, unique: true },
    bedtimeWeeknight: { type: String, default: "21:00" },
    bedtimeWeekend: { type: String, default: "23:00" },
    uninstallProtection: { type: Boolean, default: false },
    locationTracking: { type: Boolean, default: true }
});

// 9. Push Notification Subscriptions
const PushSubscriptionSchema = new mongoose.Schema({
    userId: { type: String, required: true, unique: true }, // Links to the parent
    subscription: { type: Object, required: true }          // Browser's endpoint data
});

// Compile schemas into usable Models
const User = mongoose.model('User', UserSchema);
const Device = mongoose.model('Device', DeviceSchema);
const Location = mongoose.model('Location', LocationSchema);
const AppRule = mongoose.model('AppRule', AppRuleSchema);
const WebFilter = mongoose.model('WebFilter', WebFilterSchema);
const Zone = mongoose.model('Zone', ZoneSchema);
const Alert = mongoose.model('Alert', AlertSchema);
const Settings = mongoose.model('Settings', SettingsSchema);
const PushSubscription = mongoose.model('PushSubscription', PushSubscriptionSchema);










// ==========================================
// --- AUTHENTICATION MIDDLEWARE ---
// ==========================================
// Why: Protects specific routes so only logged-in parents with a valid token can access them.
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Extract token from "Bearer <token>"
    if (!token) return res.sendStatus(401);

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) return res.sendStatus(403);
        req.user = user; // Attach user info to the request for the next function to use
        next(); // Proceed to the actual route handler
    });
};






// ============================================
// --- TEST: RANDOM FIREBASE NOTIFICATIONS TO ANDROID ---
// ============================================
setInterval(async () => {
    try {
        // Find all Android devices that have successfully sent their FCM token
        const devices = await Device.find({ fcmToken: { $exists: true, $ne: null } });
        
        if (devices.length > 0) {
            const randomMessages = [
                "Please finish your homework!",
                "Dinner is ready in 10 minutes.",
                "You have 30 minutes of screen time left.",
                "Great job limiting your screen time today!"
            ];
            
            // Pick a random message
            const randomText = randomMessages[Math.floor(Math.random() * randomMessages.length)];

            for (const device of devices) {
                const message = {
                    // The 'notification' block tells Android to show a visible popup banner
                    notification: {
                        title: "Message from Parent",
                        body: randomText
                    },
                    // The 'data' block is silent background data your app can read
                    data: {
                        action: "TEST_MESSAGE"
                    },
                    token: device.fcmToken
                };

                // Send the push notification to Google/Android
                await admin.messaging().send(message);
                console.log(`üì± [FCM] üì§ Random test notification sent to Android (${device.deviceId})`);
            }
        }
    } catch (error) {
        console.error("üì± [FCM] ‚ùå Failed to send test notification:", error.message);
    }
}, 2 * 60 * 1000); // Runs every 2 minutes (120,000 ms)



// ============================================
// --- FRONTEND ROUTES ---
// ============================================
app.get('/', (req, res) => res.sendFile(path.join(rootPath, 'index.html')));
app.get('/dashboard', (req, res) => res.sendFile(path.join(rootPath, 'public', 'dashboard.html')));







// ==========================================
// --- API ROUTES: AUTHENTICATION ---
// ==========================================

// Register a new parent account
app.post('/api/auth/register', async (req, res) => {
    try {
        const user = new User({ email: req.body.email, password: req.body.password });
        await user.save();
        console.log(`üë§ [AUTH] ‚úÖ New user registered: ${req.body.email}`);
        res.status(201).send({ message: 'User created' });
    } catch (error) {
        console.error(`üë§ [AUTH] ‚ùå Registration error:`, error.message);
        res.status(500).send(error.message);
    }
});

// Login and receive a JWT token
app.post('/api/auth/login', async (req, res) => {
    const user = await User.findOne({ email: req.body.email });
    if (!user) {
        console.log(`üë§ [AUTH] ‚ö†Ô∏è Failed login attempt: Unknown email (${req.body.email})`);
        return res.status(400).send('Cannot find user');
    }
    try {
        if (req.body.password === user.password) {
            const token = jwt.sign({ userId: user._id }, JWT_SECRET);
            console.log(`üë§ [AUTH] ‚úÖ User logged in: ${user.email}`);
            res.json({ token, email: user.email });
        } else {
            console.log(`üë§ [AUTH] ‚ö†Ô∏è Failed login attempt: Wrong password (${user.email})`);
            res.status(403).send('Not Allowed');
        }
    } catch (error) {
        res.status(500).send(error.message);
    }
});













app.post('/api/devices/update-token', async (req, res) => {
    try {
        const { deviceId, fcmToken } = req.body;
        await Device.findOneAndUpdate(
            { deviceId: deviceId },
            { $set: { fcmToken: fcmToken } }
        );
        console.log(`üì± [FCM] Token updated for device ${deviceId}`);
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});


// ==========================================
// --- API ROUTES: DEVICE MANAGEMENT ---
// ==========================================

// Get all devices owned by the logged-in parent
app.get('/api/devices', authenticateToken, async (req, res) => {
    try {
        const devices = await Device.find({ userId: req.user.userId });
        res.json(devices);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Completely delete a device and ALL its associated data
app.delete('/api/devices/:deviceId', authenticateToken, async (req, res) => {
    try {
        const { deviceId } = req.params;
        const device = await Device.findOne({ _id: deviceId, userId: req.user.userId });

        if (!device) return res.status(404).json({ error: 'Device not found' });

        // Clean up all related child data
        await Location.deleteMany({ deviceId: device.deviceId });
        await AppRule.deleteMany({ deviceId: device.deviceId });
        await WebFilter.deleteOne({ deviceId: device.deviceId });
        await Zone.deleteMany({ deviceId: device.deviceId });
        await Device.deleteOne({ _id: deviceId });

        console.log(`üì± [DEVICE] üóëÔ∏è Deleted device and data: ${device.name} (${deviceId})`);
        res.json({ success: true, message: 'Device deleted successfully' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Cancel a pairing session if the parent closes the pairing modal early
app.post('/api/devices/cancel-pairing', authenticateToken, async (req, res) => {
    try {
        const { code } = req.body;
        if (pendingPairings[code]) {
            if (pendingPairings[code].timeoutId) clearTimeout(pendingPairings[code].timeoutId);
            delete pendingPairings[code];
            console.log(`üì± [PAIRING] ‚ùå Cancelled for code: ${code}`);
            res.json({ success: true });
        } else {
            res.status(404).json({ error: 'Pairing code not found' });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Generate a 6-digit code for the parent to type into the child's phone
app.post('/api/devices/add', authenticateToken, async (req, res) => {
    try {
        let code;
        // Ensure the randomly generated code is entirely unique
        do {
            code = Math.floor(100000 + Math.random() * 900000).toString();
        } while (pendingPairings[code]);

        pendingPairings[code] = {
            userId: req.user.userId,
            socketId: null, // Will connect when dashboard loads WebSocket
            timestamp: Date.now()
        };

        // Automatically expire the code after 2 minutes for security
        const timeoutId = setTimeout(() => {
            if (pendingPairings[code]) {
                const socketId = pendingPairings[code].socketId;
                if (socketId && io.sockets.sockets.get(socketId)) {
                    io.to(socketId).emit('pairing_timeout', { code });
                }
                delete pendingPairings[code];
                console.log(`üì± [PAIRING] ‚è∞ Code expired: ${code}`);
            }
        }, 2 * 60 * 1000); 

        pendingPairings[code].timeoutId = timeoutId;
        console.log(`üì± [PAIRING] üîë Generated code: ${code} for user ${req.user.userId}`);
        res.json({ code });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Triggered by the Android app when the child inputs the 6-digit code
app.post('/api/devices/pair', async (req, res) => {
    try {
        const { code, deviceId, deviceName } = req.body; 
        
        if (!pendingPairings[code]) {
            console.log(`üì± [PAIRING] ‚ö†Ô∏è Failed attempt: Invalid code (${code}) from device ${deviceId}`);
            return res.status(404).json({ success: false, message: 'Invalid or expired code' });
        }

        const pendingPairing = pendingPairings[code];
        if (pendingPairing.timeoutId) clearTimeout(pendingPairing.timeoutId);

        // Save the newly linked device to the database
        const device = new Device({
            userId: pendingPairing.userId,
            deviceId: deviceId,
            name: deviceName || "Child Device",
            pairingCode: code,
            isPaired: true
        });
        await device.save();

        // Tell the Parent's Dashboard (via WebSocket) that the phone was successfully linked
        if (pendingPairing.socketId && io.sockets.sockets.get(pendingPairing.socketId)) {
            io.to(pendingPairing.socketId).emit('pairing_success', { 
                device: {
                    id: device._id,
                    name: device.name,
                    deviceId: device.deviceId,
                    isPaired: true
                }
            });
        }

        delete pendingPairings[code]; // Cleanup memory
        console.log(`üì± [PAIRING] ‚úÖ Success! Device paired: ${deviceName} (${deviceId})`);
        res.json({ success: true, deviceId: device._id });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
















// ==========================================
// --- API ROUTES: APP USAGE & RULES ---
// ==========================================

// CRON JOB: Resets the "usedToday" counter for all apps to 0 at midnight
cron.schedule('0 0 * * *', async () => {
    try {
        console.log(`‚è±Ô∏è [CRON] üåÖ Starting daily app usage reset...`);
        await AppRule.updateMany({}, { $set: { usedToday: 0 } });
        console.log(`‚è±Ô∏è [CRON] ‚úÖ Daily reset complete.`);
    } catch (err) {
        console.error(`‚è±Ô∏è [CRON] ‚ùå Daily reset failed:`, err);
    }
}, { timezone: DAILY_RESET_TZ });

// Triggered by the Android app to upload the latest screen time stats
app.post('/api/apps', async (req, res) => {
    try {
        const { deviceId, apps } = req.body; 
        
        if (apps && Array.isArray(apps)) {
            for (const app of apps) {
                if (!app || !app.packageName) continue;

                const update = {
                    $set: {
                        appName: app.appName || app.packageName,
                        category: app.category || 'General',
                    },
                    $setOnInsert: { isGlobalLocked: false, timeLimit: 0 }
                };

                // Handles incoming time. (Android might send total daily minutes, or just recent seconds)
                let incomingMinutes = NaN;
                if (app.minutes !== undefined && app.minutes !== null) incomingMinutes = Number(app.minutes);

                let incomingSeconds = NaN;
                if (app.seconds !== undefined && app.seconds !== null) incomingSeconds = Number(app.seconds);

                if (Number.isFinite(incomingMinutes)) {
                    update.$set.usedToday = Math.max(0, incomingMinutes);
                } else if (Number.isFinite(incomingSeconds)) {
                    update.$inc = { usedToday: Math.max(0, incomingSeconds) / 60 }; // Convert seconds to minutes
                } else if (app.initialSync) {
                    update.$set.usedToday = 0;
                }

                // Upsert: Update if it exists, create if it doesn't
                await AppRule.findOneAndUpdate(
                    { deviceId, packageName: app.packageName },
                    update,
                    { upsert: true }
                );
            }
        }
        res.json({ success: true });
    } catch (error) {
        console.error("üîÑ [SYNC] ‚ùå Error updating app usage:", error);
        res.status(500).json({ error: error.message });
    }
});

// Endpoint for Android app to ask: "Which apps should I block right now?"
app.get('/api/rules/blocked/:deviceId', async (req, res) => {
    try {
        const { deviceId } = req.params;
        
        // Find apps that are fully locked OR have exceeded their daily time limit
        const rules = await AppRule.find({
            deviceId: deviceId,
            $or: [
                { isGlobalLocked: true },
                { $expr: { $and: [ { $gt: ["$timeLimit", 0] }, { $gte: ["$usedToday", "$timeLimit"] } ] } }
            ]
        });

        // Send back a clean array of package names (e.g., ["com.instagram.android", "com.snapchat.android"])
        const blockedPackages = rules.map(r => r.packageName);
        res.json({ blockedPackages });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Parent Dashboard fetches the list of apps to show on the UI
app.get('/api/data/:deviceId/apps', authenticateToken, async (req, res) => {
    try {
        const apps = await AppRule.find({ deviceId: req.params.deviceId });
        res.json(apps);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Parent saves changes to App locks, schedules, or limits
app.post('/api/rules/update', authenticateToken, async (req, res) => {
    try {
        const { deviceId, packageName, isGlobalLocked, schedules, timeLimit } = req.body;
        
        const updateFields = {};
        if (isGlobalLocked !== undefined) updateFields.isGlobalLocked = isGlobalLocked;
        if (schedules !== undefined) updateFields.schedules = schedules;
        if (timeLimit !== undefined) updateFields.timeLimit = timeLimit;

        await AppRule.findOneAndUpdate(
            { deviceId, packageName },
            { $set: updateFields },
            { new: true }
        );
        console.log(`üîí [RULES] Updated rules for ${packageName} on device ${deviceId}`);
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});













// ==========================================
// --- API ROUTES: WEB SAFETY & FILTERING ---
// ==========================================

// Triggered by Android Accessibility Service sending URLs the child visited
app.post('/api/browser-history', async (req, res) => {
    try {
        const { deviceId, history } = req.body; // format: ["url|time", "url|time"]

        if (!deviceId || !history || history.length === 0) {
            return res.status(400).json({ error: "Missing data" });
        }

        let filter = await WebFilter.findOne({ deviceId: deviceId });
        if (!filter) {
            filter = new WebFilter({ deviceId, blockedCategories: [], blockedUrls: [], history: [] });
        }

        // Clean up the string data sent by Android into proper Objects
        const newEntries = history.map(item => {
            const parts = item.split('|');
            return {
                title: "Visited Site", 
                url: parts[0],
                riskScore: 0, 
                timestamp: new Date(parseInt(parts[1]) || Date.now())
            };
        });

        filter.history.push(...newEntries);
        await filter.save();

        console.log(`üåê [WEB] ‚úÖ Saved ${newEntries.length} history items for ${deviceId}`);
        res.json({ success: true });
    } catch (error) {
        console.error("üåê [WEB] ‚ùå Save History Error:", error);
        res.status(500).json({ error: error.message });
    }
});

// Parent Dashboard requests the web rules and browsing history
app.get('/api/web/:deviceId', authenticateToken, async (req, res) => {
    try {
        let filter = await WebFilter.findOne({ deviceId: req.params.deviceId });
        if (!filter) {
            return res.json({ deviceId: req.params.deviceId, history: [] });
        }
        res.json(filter);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Parent updates blocked categories or specific custom URLs
app.post('/api/web/update', authenticateToken, async (req, res) => {
    try {
        const { deviceId, blockedCategories, blockedUrls } = req.body;
        const updateFields = {};
        if (blockedCategories) updateFields.blockedCategories = blockedCategories;
        if (blockedUrls) updateFields.blockedUrls = blockedUrls;

        await WebFilter.findOneAndUpdate(
            { deviceId },
            { $set: updateFields },
            { upsert: true, new: true }
        );
        console.log(`üåê [WEB] Config updated for ${deviceId}`);
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Call Google's Gemini AI to analyze the child's web history for risks
app.post('/api/web/analyze', authenticateToken, async (req, res) => {
    try {
        const { history, blockedCategories } = req.body;
        
        console.log(`üß† [AI] Requesting Gemini analysis...`);
        
        // Prepare prompt string for the AI
        const historyText = history.map(h => `- [${h.riskScore}/100] ${h.title} (${h.url})`).join('\n');
        const prompt = `
            Act as a parental safety expert AI.
            
            **Configuration:**
            The parent has explicitly blocked these categories: ${blockedCategories.length > 0 ? blockedCategories.join(', ').toUpperCase() : 'NONE (Monitor only)'}.
            
            **Child's History:**
            ${historyText}
            
            **Instructions:**
            1. Analyze the history against the BLOCKED CATEGORIES. If the child visited sites that fit these categories, flag them as HIGH RISK.
            2. Even if no custom URL blacklist exists, use your knowledge to identify sites that match the blocked categories.
            3. Provide a 2-sentence summary of the child's behavior and any immediate actions the parent should take.
        `;

        // Fetch to Google API
        const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${process.env.GEMINI_API_KEY}`;
        const response = await fetch(geminiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
        });

        const data = await response.json();
        
        if (data.candidates && data.candidates[0].content) {
            console.log(`üß† [AI] ‚úÖ Analysis generated successfully.`);
            res.json({ analysis: data.candidates[0].content.parts[0].text });
        } else {
            res.json({ analysis: "Could not generate analysis at this time." });
        }
    } catch (error) {
        console.error("üß† [AI] ‚ùå Gemini Error:", error);
        res.status(500).json({ error: "AI Analysis Failed" });
    }
});
















// ==========================================
// --- GEOFENCING & LOCATION LOGIC ---
// ==========================================

// HELPER: Ray-Casting Algorithm
// Why: Determines if a GPS point (Child) is physically inside a drawn Polygon (Zone).
// It casts an imaginary horizontal line from the child's location and counts how many times 
// it crosses the borders of the polygon. Odd number = Inside. Even number = Outside.
function isPointInPolygon(point, vs) {
    let x = point.lat, y = point.lng;
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        let xi = vs[i].lat, yi = vs[i].lng;
        let xj = vs[j].lat, yj = vs[j].lng;
        
        let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

// Parent dashboard requests list of map zones
app.get('/api/zones/:deviceId', authenticateToken, async (req, res) => {
    try {
        const zones = await Zone.find({ deviceId: req.params.deviceId }).sort({ createdAt: -1 });
        res.json(zones);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Parent creates a new zone
app.post('/api/zones/add', authenticateToken, async (req, res) => {
    try {
        const { deviceId, name, type, alertMessage, points } = req.body;
        if (!deviceId || !name || !points || points.length < 3) {
            return res.status(400).json({ error: "Invalid zone data" });
        }

        const newZone = new Zone({ deviceId, name, type, alertMessage, points });
        await newZone.save();
        console.log(`üìç [ZONE] ‚úÖ Created new zone: ${name}`);
        res.json({ success: true, zone: newZone });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Parent deletes a zone
app.delete('/api/zones/:zoneId', authenticateToken, async (req, res) => {
    try {
        await Zone.findByIdAndDelete(req.params.zoneId);
        console.log(`üìç [ZONE] üóëÔ∏è Deleted zone ${req.params.zoneId}`);
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Parent Dashboard gets the child's LAST known location
app.get('/api/data/:deviceId/location', authenticateToken, async (req, res) => {
    try {
        const location = await Location.findOne({ deviceId: req.params.deviceId }).sort({ timestamp: -1 });
        res.json(location || {});
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Child device uploads its CURRENT location (This triggers the Zone checking logic)
app.post('/api/location', async (req, res) => {
    try {
        const { deviceId, latitude, longitude, batteryLevel } = req.body;
        
        // 1. Save Location to DB
        const loc = new Location({ deviceId, latitude, longitude, batteryLevel });
        await loc.save();

        // 2. Perform Geofence Calculation to see if child breached a zone
        const zones = await Zone.find({ deviceId });
        
        for (const zone of zones) {
            const isInside = isPointInPolygon({ lat: latitude, lng: longitude }, zone.points);
            
            if (isInside) {
                // Prevent notification spam by ensuring we haven't sent this exact alert in the last 5 minutes
                const lastAlert = await Alert.findOne({ 
                    deviceId, 
                    message: `Geofence Trigger: ${zone.alertMessage}` 
                }).sort({ timestamp: -1 });

                const fiveMinsAgo = new Date(Date.now() - 5 * 60 * 1000);
                
                if (!lastAlert || lastAlert.timestamp < fiveMinsAgo) {
                    console.log(`üìç [GEOFENCE] üö® Breach detected for device ${deviceId} in zone: ${zone.name}`);
                    const alertType = zone.type === 'danger' ? 'critical' : 'info';
                    
                    await new Alert({
                        deviceId,
                        message: `Geofence Trigger: ${zone.alertMessage}`,
                        type: alertType
                    }).save();
                }
            }
        }
        res.json({ success: true });
    } catch (error) {
        console.error(`üìç [GEOFENCE] ‚ùå Error calculating location:`, error);
        res.status(500).json({ error: error.message });
    }
});

// Frontend polls this to show notifications in the UI Bell icon
app.get('/api/alerts/:deviceId', authenticateToken, async (req, res) => {
    const alerts = await Alert.find({ deviceId: req.params.deviceId }).sort({ timestamp: -1 }).limit(10);
    res.json(alerts);
});













// ==========================================
// --- API ROUTES: GENERAL SETTINGS ---
// ==========================================

app.get('/api/settings/:deviceId', async (req, res) => {
    try {
        let settings = await Settings.findOne({ deviceId: req.params.deviceId });
        if (!settings) {
            settings = new Settings({ deviceId: req.params.deviceId });
            await settings.save();
        }
        res.json(settings);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/settings/update', authenticateToken, async (req, res) => {
    try {
        const { deviceId, bedtimeWeeknight, bedtimeWeekend, uninstallProtection, locationTracking } = req.body;
        
        // 1. Save settings to MongoDB
        const settings = await Settings.findOneAndUpdate(
            { deviceId },
            { $set: { bedtimeWeeknight, bedtimeWeekend, uninstallProtection, locationTracking } },
            { new: true, upsert: true }
        );
        
        // 2. Find the Android device's FCM Token
        const device = await Device.findOne({ deviceId: deviceId });
        
        if (device && device.fcmToken) {
            // 3. Send a SILENT data message to Android
            const message = {
                data: {
                    action: "SYNC_SETTINGS" // Tells Android what to do
                },
                token: device.fcmToken
            };

            await admin.messaging().send(message);
            console.log(`üöÄ [FCM] Silent ping sent to wake up device ${deviceId}!`);
        }

        res.json({ success: true, settings });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: error.message });
    }
});













// ============================================
// --- PUSH NOTIFICATIONS (WEB PUSH) ---
// ============================================

// 1. Configure Web Push with VAPID keys (Used to securely identify your server to Google/Apple push services)
webpush.setVapidDetails(
    'mailto:debashishtelgram@gmail.com', // Developer contact email
    process.env.VAPID_PUBLIC_KEY,
    process.env.VAPID_PRIVATE_KEY
);

// 2. Browser sends its generated subscription object here to be saved
app.post('/api/notifications/subscribe', authenticateToken, async (req, res) => {
    try {
        const subscription = req.body;
        await PushSubscription.findOneAndUpdate(
            { userId: req.user.userId }, 
            { subscription: subscription },
            { upsert: true, new: true }
        );
        console.log(`üîî [PUSH] ‚úÖ User ${req.user.userId} subscribed to notifications.`);
        res.status(201).json({ success: true, message: "Subscribed to push" });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// 3. Helper Function to actually send a push notification to a parent's computer/phone
async function sendNotificationToParent(userId, title, body) {
    try {
        const subRecord = await PushSubscription.findOne({ userId: userId });
        
        if (!subRecord) {
            console.log(`üîî [PUSH] ‚ö†Ô∏è No subscription found for user ${userId}`);
            return;
        }

        const payload = JSON.stringify({
            title: title,
            body: body,
            icon: '/shield-icon.png', 
            url: '/dashboard.html'    
        });

        await webpush.sendNotification(subRecord.subscription, payload);
        console.log(`üîî [PUSH] üì§ Notification sent to ${userId}`);

    } catch (error) {
        console.error(`üîî [PUSH] ‚ùå Failed to send push:`, error.message);
        // Error 410 means the user manually revoked browser permissions. We should delete their record.
        if (error.statusCode === 410) {
            await PushSubscription.deleteOne({ userId: userId });
            console.log(`üîî [PUSH] üóëÔ∏è Deleted expired subscription for ${userId}`);
        }
    }
}

// 4. TEST INTERVAL: Randomly send a notification every 2 minutes to prove the system works
setInterval(async () => {
    const allSubscribers = await PushSubscription.find({});
    
    if (allSubscribers.length > 0) {
        const randomTitles = ["App Alert", "Location Update", "Daily Summary"];
        const randomBodies = [
            "Child device has been online for 2 hours.",
            "Child arrived at 'School' safe zone.",
            "New blocked app attempt detected."
        ];

        const title = randomTitles[Math.floor(Math.random() * randomTitles.length)];
        const body = randomBodies[Math.floor(Math.random() * randomBodies.length)];

        // In a real scenario, you wouldn't loop through everyone, you'd target a specific parent.
        for (const sub of allSubscribers) {
            sendNotificationToParent(sub.userId, title, body);
        }
    }
}, 2 * 60 * 1000); // 120,000 ms














// ============================================
// --- WEBSOCKET HANDLERS (Real-time events) ---
// ============================================
io.on('connection', (socket) => {
    console.log(`üîå [SOCKET] Client connected: ${socket.id}`);

    // Frontend Dashboard asks server to notify it when a specific pairing code is claimed
    socket.on('register_pairing', (data) => {
        const { code } = data;
        if (pendingPairings[code]) {
            pendingPairings[code].socketId = socket.id;
            console.log(`üîå [SOCKET] Dashboard registered for pairing code: ${code}`);
        }
    });

    // Frontend requests to delete a device over the socket rather than HTTP
    socket.on('delete_device', async (data) => {
        try {
            const { deviceId, token } = data;
            const decoded = jwt.verify(token, JWT_SECRET); // Verify the parent is authorized
            
            const device = await Device.findOne({ _id: deviceId, userId: decoded.userId });

            if (!device) {
                socket.emit('delete_error', { error: 'Device not found' });
                return;
            }

            // Cleanup DB
            await Location.deleteMany({ deviceId: device.deviceId });
            await AppRule.deleteMany({ deviceId: device.deviceId });
            await WebFilter.deleteOne({ deviceId: device.deviceId });
            await Zone.deleteMany({ deviceId: device.deviceId });
            await Device.deleteOne({ _id: deviceId });

            // Tell frontend to remove it from UI
            socket.emit('delete_success', { deviceId });
            console.log(`üîå [SOCKET] üóëÔ∏è Device deleted via socket: ${device.name}`);
        } catch (error) {
            socket.emit('delete_error', { error: error.message });
        }
    });

    socket.on('disconnect', () => {
        console.log(`üîå [SOCKET] Client disconnected: ${socket.id}`);
    });
});








// ============================================
// --- START SERVER ---
// ============================================
server.listen(PORT, () => {
    console.log(`\n======================================`);
    console.log(`üöÄ [SERVER] Running smoothly on port ${PORT}`);
    console.log(`======================================\n`);
});










